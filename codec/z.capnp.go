// Code generated by capnpc-go. DO NOT EDIT.

package codec

import (
	strconv "strconv"
	capnp "zombiezen.com/go/capnproto2"
	text "zombiezen.com/go/capnproto2/encoding/text"
	schemas "zombiezen.com/go/capnproto2/schemas"
)

type Z struct{ capnp.Struct }
type Z_Which uint16

const (
	Z_Which_ping        Z_Which = 0
	Z_Which_pong        Z_Which = 1
	Z_Which_discover    Z_Which = 2
	Z_Which_peers       Z_Which = 3
	Z_Which_transaction Z_Which = 4
	Z_Which_mempool     Z_Which = 5
	Z_Which_inventory   Z_Which = 6
	Z_Which_request     Z_Which = 7
	Z_Which_batch       Z_Which = 8
)

func (w Z_Which) String() string {
	const s = "pingpongdiscoverpeerstransactionmempoolinventoryrequestbatch"
	switch w {
	case Z_Which_ping:
		return s[0:4]
	case Z_Which_pong:
		return s[4:8]
	case Z_Which_discover:
		return s[8:16]
	case Z_Which_peers:
		return s[16:21]
	case Z_Which_transaction:
		return s[21:32]
	case Z_Which_mempool:
		return s[32:39]
	case Z_Which_inventory:
		return s[39:48]
	case Z_Which_request:
		return s[48:55]
	case Z_Which_batch:
		return s[55:60]

	}
	return "Z_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Z_TypeID is the unique identifier for the type Z.
const Z_TypeID = 0xb46d352733d41eba

func NewZ(s *capnp.Segment) (Z, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Z{st}, err
}

func NewRootZ(s *capnp.Segment) (Z, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Z{st}, err
}

func ReadRootZ(msg *capnp.Message) (Z, error) {
	root, err := msg.RootPtr()
	return Z{root.Struct()}, err
}

func (s Z) String() string {
	str, _ := text.Marshal(0xb46d352733d41eba, s.Struct)
	return str
}

func (s Z) Which() Z_Which {
	return Z_Which(s.Struct.Uint16(0))
}
func (s Z) Ping() (Ping, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != ping")
	}
	p, err := s.Struct.Ptr(0)
	return Ping{Struct: p.Struct()}, err
}

func (s Z) HasPing() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Z) SetPing(v Ping) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewPing sets the ping field to a newly
// allocated Ping struct, preferring placement in s's segment.
func (s Z) NewPing() (Ping, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewPing(s.Struct.Segment())
	if err != nil {
		return Ping{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Z) Pong() (Pong, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != pong")
	}
	p, err := s.Struct.Ptr(0)
	return Pong{Struct: p.Struct()}, err
}

func (s Z) HasPong() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Z) SetPong(v Pong) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewPong sets the pong field to a newly
// allocated Pong struct, preferring placement in s's segment.
func (s Z) NewPong() (Pong, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewPong(s.Struct.Segment())
	if err != nil {
		return Pong{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Z) Discover() (Discover, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != discover")
	}
	p, err := s.Struct.Ptr(0)
	return Discover{Struct: p.Struct()}, err
}

func (s Z) HasDiscover() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Z) SetDiscover(v Discover) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDiscover sets the discover field to a newly
// allocated Discover struct, preferring placement in s's segment.
func (s Z) NewDiscover() (Discover, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := NewDiscover(s.Struct.Segment())
	if err != nil {
		return Discover{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Z) Peers() (Peers, error) {
	if s.Struct.Uint16(0) != 3 {
		panic("Which() != peers")
	}
	p, err := s.Struct.Ptr(0)
	return Peers{Struct: p.Struct()}, err
}

func (s Z) HasPeers() bool {
	if s.Struct.Uint16(0) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Z) SetPeers(v Peers) error {
	s.Struct.SetUint16(0, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewPeers sets the peers field to a newly
// allocated Peers struct, preferring placement in s's segment.
func (s Z) NewPeers() (Peers, error) {
	s.Struct.SetUint16(0, 3)
	ss, err := NewPeers(s.Struct.Segment())
	if err != nil {
		return Peers{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Z) Transaction() (Transaction, error) {
	if s.Struct.Uint16(0) != 4 {
		panic("Which() != transaction")
	}
	p, err := s.Struct.Ptr(0)
	return Transaction{Struct: p.Struct()}, err
}

func (s Z) HasTransaction() bool {
	if s.Struct.Uint16(0) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Z) SetTransaction(v Transaction) error {
	s.Struct.SetUint16(0, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTransaction sets the transaction field to a newly
// allocated Transaction struct, preferring placement in s's segment.
func (s Z) NewTransaction() (Transaction, error) {
	s.Struct.SetUint16(0, 4)
	ss, err := NewTransaction(s.Struct.Segment())
	if err != nil {
		return Transaction{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Z) Mempool() (Mempool, error) {
	if s.Struct.Uint16(0) != 5 {
		panic("Which() != mempool")
	}
	p, err := s.Struct.Ptr(0)
	return Mempool{Struct: p.Struct()}, err
}

func (s Z) HasMempool() bool {
	if s.Struct.Uint16(0) != 5 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Z) SetMempool(v Mempool) error {
	s.Struct.SetUint16(0, 5)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewMempool sets the mempool field to a newly
// allocated Mempool struct, preferring placement in s's segment.
func (s Z) NewMempool() (Mempool, error) {
	s.Struct.SetUint16(0, 5)
	ss, err := NewMempool(s.Struct.Segment())
	if err != nil {
		return Mempool{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Z) Inventory() (Inventory, error) {
	if s.Struct.Uint16(0) != 6 {
		panic("Which() != inventory")
	}
	p, err := s.Struct.Ptr(0)
	return Inventory{Struct: p.Struct()}, err
}

func (s Z) HasInventory() bool {
	if s.Struct.Uint16(0) != 6 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Z) SetInventory(v Inventory) error {
	s.Struct.SetUint16(0, 6)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewInventory sets the inventory field to a newly
// allocated Inventory struct, preferring placement in s's segment.
func (s Z) NewInventory() (Inventory, error) {
	s.Struct.SetUint16(0, 6)
	ss, err := NewInventory(s.Struct.Segment())
	if err != nil {
		return Inventory{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Z) Request() (Request, error) {
	if s.Struct.Uint16(0) != 7 {
		panic("Which() != request")
	}
	p, err := s.Struct.Ptr(0)
	return Request{Struct: p.Struct()}, err
}

func (s Z) HasRequest() bool {
	if s.Struct.Uint16(0) != 7 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Z) SetRequest(v Request) error {
	s.Struct.SetUint16(0, 7)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewRequest sets the request field to a newly
// allocated Request struct, preferring placement in s's segment.
func (s Z) NewRequest() (Request, error) {
	s.Struct.SetUint16(0, 7)
	ss, err := NewRequest(s.Struct.Segment())
	if err != nil {
		return Request{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s Z) Batch() (Batch, error) {
	if s.Struct.Uint16(0) != 8 {
		panic("Which() != batch")
	}
	p, err := s.Struct.Ptr(0)
	return Batch{Struct: p.Struct()}, err
}

func (s Z) HasBatch() bool {
	if s.Struct.Uint16(0) != 8 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Z) SetBatch(v Batch) error {
	s.Struct.SetUint16(0, 8)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewBatch sets the batch field to a newly
// allocated Batch struct, preferring placement in s's segment.
func (s Z) NewBatch() (Batch, error) {
	s.Struct.SetUint16(0, 8)
	ss, err := NewBatch(s.Struct.Segment())
	if err != nil {
		return Batch{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// Z_List is a list of Z.
type Z_List struct{ capnp.List }

// NewZ creates a new list of Z.
func NewZ_List(s *capnp.Segment, sz int32) (Z_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return Z_List{l}, err
}

func (s Z_List) At(i int) Z { return Z{s.List.Struct(i)} }

func (s Z_List) Set(i int, v Z) error { return s.List.SetStruct(i, v.Struct) }

func (s Z_List) String() string {
	str, _ := text.MarshalList(0xb46d352733d41eba, s.List)
	return str
}

// Z_Promise is a wrapper for a Z promised by a client call.
type Z_Promise struct{ *capnp.Pipeline }

func (p Z_Promise) Struct() (Z, error) {
	s, err := p.Pipeline.Struct()
	return Z{s}, err
}

func (p Z_Promise) Ping() Ping_Promise {
	return Ping_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Z_Promise) Pong() Pong_Promise {
	return Pong_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Z_Promise) Discover() Discover_Promise {
	return Discover_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Z_Promise) Peers() Peers_Promise {
	return Peers_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Z_Promise) Transaction() Transaction_Promise {
	return Transaction_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Z_Promise) Mempool() Mempool_Promise {
	return Mempool_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Z_Promise) Inventory() Inventory_Promise {
	return Inventory_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Z_Promise) Request() Request_Promise {
	return Request_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p Z_Promise) Batch() Batch_Promise {
	return Batch_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

const schema_904d4f3f728c7f04 = "x\xda4\xce?h\x13\x7f\x1c\xc6\xf1\xe7\xb9\xfb\xe6\x1f" +
	"\xbf\xe4\xd7o\xb8+\xa8\xa8q\x10D\xc1\x7f)\x8a\xe8" +
	"\xd0\"\x08E\xd0x\x89.f\x904\x1e\x1ah\xee\xce" +
	"\xcbY\xd4\xa5\x9b\x7f\x8a\x05\xc5\xd1A\x07\x11\x84:\x08" +
	"\xea\xa0\xb8\xe9\xe0(\xba\xe8\xa0S!C\x14\xc5\x8a\xb1" +
	"Z?\xf2-\xc9\xfa~\xf1\xc0\xb3\xeb9'\xac\xdd\xa9" +
	"J\x0e\xf0\xa6Siy\xb6\xf1\xdd\xd8\x96=\xed\xc7\xf0" +
	"\xb2\xa4\xa8\xd9\xeb\xf1x\xe5\xc8\x0d\x1cb&\x078\xf3" +
	"\xaa\xea\xdcT\x19`l^\x09!(\xc9\xa5\x1d\xcdF" +
	"\x14D\xfb\xc1\x93\xc7Ho\xb3\xad\xf2\"\x8a@\xf1\xf3" +
	"6\xc0\xeb\xda\xf4\x96,\x16\xf8W\\\x9a\xfa\xcd\xd4\x9e" +
	"M\xafo\xb1`\xad\x88K\x0b(\xfe8\x0cxK6" +
	"\xab\xb4X\xb0\xff\x88K\x1b(\xae\x94\x01\xafo\xb3\xa6" +
	"LV\xbf\xc5\xa5\x02\x1cr\x0a\xa8\xd2f-ozj" +
	"Y\\\xa6\x00'\xc7\x83@M\x19\xd0\x06\xd2\xbf\xc4e" +
	"\x1ap\x0a\xac\x02\xb5\xbc\x815\x062}q\x99\x01\x9c" +
	"\xd1\xd5\x856\xb0\xde@\xf6\xa7\xb8\xcc\x02\xceZ\x96\x81" +
	"\x9ak`\x13-\x8eD\xad\xe0\x0c\xb5,\x96>|\xff" +
	"8\xf9\xf2\x1e@jp$\x0aW\xb3l\xbf[\x91\xf2" +
	"\x93\xc5A\x96\xd3\xadN3\x9c\xf1c\x00\xd4r\xe1\xe9" +
	"\xfd\xbd\xdd\x89\xde\xdc@K\x91\xef\xc7\x1djYW\xad" +
	"\xbf\xda\xb0<\xf7b\xb8J\xe2F\xd0i4\x13dZ" +
	"a@-\xa7\xec\xado\xd2\xef\xef\xf4\x06>\xdb\xf6\xdb" +
	"Q\x18NS\xcb\xe8\xc2\xce\x13\x0f\xff\xdf\xf7u\xb8l" +
	"\x053~\x90\x841x\x91Z\xae~\xfa\xef\xf6\xa3\xe3" +
	"\x93\xd7\x86\xbb\xd8?w\xde\xef$\xd4r\xeb\xc0\xeb\xf1" +
	"+\xc5\xb7\xdd\xe1\x93\xa9F\xd2<K-_\x16\xea\xf5" +
	"\x07\xde\xd1\xcb\x83\xfe/\x00\x00\xff\xff<C\x89\xb1"

func init() {
	schemas.Register(schema_904d4f3f728c7f04,
		0xb46d352733d41eba)
}
